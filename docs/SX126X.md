# SX126x Radio Driver

This module provides a comprehensive driver for the Semtech SX126x family of sub-GHz radio transceivers, specifically optimized for wireless M-Bus (wM-Bus) applications but suitable for other sub-GHz protocols.

## Overview

The SX126x is a family of long-range, low-power radio transceivers operating in the sub-GHz ISM bands. This driver supports:

- **SX1261**: +15 dBm output power variant
- **SX1262**: +22 dBm output power variant
- **SX1268**: +22 dBm output power variant with additional features

## Architecture

The driver follows a layered architecture for maximum portability and maintainability:

```text
┌─────────────────────────────────────┐
│        Application Layer            │
├─────────────────────────────────────┤
│     Sx126xDriver (driver.rs)        │  ← High-level radio control
├─────────────────────────────────────┤
│      HAL Abstraction (hal.rs)       │  ← Platform-independent interface
├─────────────────────────────────────┤
│    Platform-specific HAL impl       │  ← Your SPI/GPIO implementation
└─────────────────────────────────────┘
```

## Module Structure

| Module          | Purpose              | Key Types                          |
|-----------------|----------------------|------------------------------------|
| `driver.rs`     | Main radio control   | `Sx126xDriver<H>`                  |
| `hal.rs`        | Hardware abstraction | `Hal` trait, `HalError`            |
| `irq.rs`        | Interrupt handling   | `IrqStatus`, `IrqMaskBit`          |
| `modulation.rs` | Modulation config    | `ModulationParams`, `PacketParams` |
| `calib.rs`      | Radio calibration    | `CalibParams`, `calibrate_radio()` |

## Quick Start

### 1. Implement the HAL trait

```rust
use crate::wmbus::radio::hal::{Hal, HalError};

struct MyHal {
    spi: MySpiDevice,
    gpio: MyGpioController,
}

impl Hal for MyHal {
    fn write_command(&mut self, opcode: u8, data: &[u8]) -> Result<(), HalError> {
        // Your SPI implementation
        todo!()
    }

    fn read_command(&mut self, opcode: u8, buf: &mut [u8]) -> Result<(), HalError> {
        // Your SPI implementation
        todo!()
    }

    // ... implement other methods
}
```

### 2. Initialize the driver

```rust
use crate::wmbus::radio::driver::Sx126xDriver;

let hal = MyHal::new(/* your SPI and GPIO setup */);
let mut driver = Sx126xDriver::new(hal, 32_000_000); // 32MHz crystal
```

### 3. Configure for wM-Bus

```rust
// One-line wM-Bus configuration
driver.configure_for_wmbus(868_950_000, 100_000)?; // 868.95 MHz, 100 kbps
```

### 4. Start receiving

```rust
driver.set_rx_continuous()?;

loop {
    if let Some(payload) = driver.process_irqs()? {
        println!("Received: {:?}", payload);
        // Process your wM-Bus frame here
    }
    std::thread::sleep(std::time::Duration::from_millis(10));
}
```

## Hardware Requirements

### SPI Interface

- **Mode**: SPI Mode 0 (CPOL=0, CPHA=0)
- **Speed**: Up to 16 MHz
- **Bit Order**: MSB first
- **Word Size**: 8 bits

### GPIO Connections

| SX126x Pin | Direction | Purpose                   | Required    |
|------------|-----------|---------------------------|-------------|
| NSS        | Output    | SPI chip select           | Yes         |
| SCLK       | Output    | SPI clock                 | Yes         |
| MOSI       | Output    | SPI data out              | Yes         |
| MISO       | Input     | SPI data in               | Yes         |
| BUSY       | Input     | Command processing status | Yes         |
| DIO1       | Input     | Primary interrupt         | Yes         |
| DIO2       | Input     | Secondary interrupt       | Optional    |
| DIO3       | Input     | Tertiary interrupt        | Optional    |
| NRESET     | Output    | Radio reset (active low)  | Recommended |

### Power Supply

- **Voltage**: 1.8V to 3.7V
- **Current**: ~12mA RX, ~80mA TX (at +14dBm)
- **Regulation**: Clean, well-regulated supply recommended

## Configuration Examples

### wM-Bus S-Mode (EU 868 MHz)

```rust
// Automatic configuration
driver.configure_for_wmbus(868_950_000, 100_000)?;

// Manual configuration (equivalent)
let mod_params = ModulationParams {
    packet_type: PacketType::Gfsk,
    params: GfskModParams {
        bitrate: 100_000,        // 100 kbps
        modulation_shaping: 1,   // Gaussian BT=0.5
        bandwidth: 156,          // 156 kHz
        fdev: 50_000,           // 50 kHz deviation
    },
};

let packet_params = PacketParams {
    packet_type: PacketType::Gfsk,
    preamble_len: 48,                    // 48-bit preamble
    header_type: HeaderType::Variable,   // Variable length
    payload_len: 255,                    // Max payload
    crc_on: true,                        // Enable CRC
    crc_type: CrcType::Byte2,           // 2-byte CRC
    sync_word_len: 4,                    // 4-byte sync word
};

driver.set_modulation_params(mod_params)?;
driver.set_packet_params(packet_params)?;
driver.set_sync_word([0xB4, 0xB6, 0x5A, 0x5A, 0, 0, 0, 0])?;
```

### Low Power Sensor Application

```rust
let mod_params = ModulationParams {
    packet_type: PacketType::Gfsk,
    params: GfskModParams {
        bitrate: 4_800,          // 4.8 kbps for longer range
        modulation_shaping: 1,   // Gaussian shaping
        bandwidth: 25,           // 25 kHz bandwidth
        fdev: 2_400,            // 2.4 kHz deviation
    },
};

let packet_params = PacketParams {
    packet_type: PacketType::Gfsk,
    preamble_len: 32,                    // Shorter preamble
    header_type: HeaderType::Fixed,      // Fixed length packets
    payload_len: 32,                     // 32-byte packets
    crc_on: true,
    crc_type: CrcType::Byte2,
    sync_word_len: 2,                    // 2-byte sync word
};

driver.set_modulation_params(mod_params)?;
driver.set_packet_params(packet_params)?;
driver.set_tx_params(10, 0x07)?; // Lower power: +10 dBm
```

## Interrupt Handling

The driver supports both polling and interrupt-driven operation:

### Polling Mode

```rust
loop {
    if let Some(payload) = driver.process_irqs()? {
        println!("Received {} bytes", payload.len());
    }
    std::thread::sleep(Duration::from_millis(10));
}
```

### Interrupt-Driven Mode

```rust
// Configure interrupt pin routing
driver.set_dio_irq_params(
    IrqMaskBit::RxDone as u16 | IrqMaskBit::TxDone as u16,
    IrqMaskBit::RxDone as u16,  // DIO1: RX done
    IrqMaskBit::TxDone as u16,  // DIO2: TX done
    0,                          // DIO3: unused
)?;

// In your interrupt handler:
fn dio1_interrupt_handler() {
    if let Some(payload) = driver.process_irqs().unwrap() {
        // Handle received data
    }
}
```

## Calibration

Calibration is essential for optimal performance:

```rust
use crate::wmbus::radio::calib::{calibrate_radio, CalibParams};

// Full calibration after power-up (recommended)
calibrate_radio(&mut hal, CalibParams::ALL)?;

// Quick PLL calibration after frequency change
calibrate_radio(&mut hal, CalibParams::PLL)?;
```

## Error Handling

The driver uses structured error types for robust error handling:

```rust
use crate::wmbus::radio::driver::DriverError;

match driver.set_rf_frequency(868_950_000) {
    Ok(()) => println!("Frequency set successfully"),
    Err(DriverError::Hal(hal_err)) => {
        eprintln!("Hardware error: {}", hal_err);
    }
    Err(DriverError::InvalidParams) => {
        eprintln!("Invalid frequency parameter");
    }
    Err(other) => eprintln!("Other error: {}", other),
}
```

## Performance Characteristics

### Sensitivity (typical at 100 kbps)

| Bandwidth | Sensitivity | Range (approx) |
|-----------|-------------|----------------|
| 156 kHz   | -123 dBm    | 2-5 km         |
| 234 kHz   | -121 dBm    | 1.5-4 km       |
| 312 kHz   | -119 dBm    | 1-3 km         |

### Current Consumption

| Mode      | Current | Notes                  |
|-----------|---------|------------------------|
| Sleep     | 0.2 µA  | Deep sleep mode        |
| Standby   | 1.6 µA  | RC oscillator on       |
| RX        | 12 mA   | Continuous receive     |
| TX +14dBm | 80 mA   | Typical wM-Bus power   |
| TX +22dBm | 120 mA  | Maximum power (SX1262) |

## Regulatory Compliance

### EU (ETSI EN 300 220)

- **Frequency**: 863-870 MHz
- **Max Power**: +14 dBm (25 mW)
- **Duty Cycle**: 1% or 10% depending on sub-band
- **Bandwidth**: 25 kHz typical

### US (FCC Part 15)

- **Frequency**: 902-928 MHz
- **Max Power**: +30 dBm (1W) with antenna gain limits
- **Spread Spectrum**: May be required for some applications

### Implementation Notes

```rust
// EU wM-Bus S-mode compliance
driver.configure_for_wmbus(868_950_000, 100_000)?;
driver.set_tx_params(14, 0x07)?; // +14 dBm (within EU limits)

// US ISM band operation
driver.configure_for_wmbus(915_000_000, 100_000)?;
driver.set_tx_params(20, 0x07)?; // +20 dBm
```

## Troubleshooting

### Common Issues

1. **No Communication**
   - Check SPI connections and configuration
   - Verify power supply voltage and stability
   - Ensure crystal oscillator is working
   - Check BUSY pin handling

2. **Poor Sensitivity**
   - Verify antenna matching and efficiency
   - Check for interference sources
   - Ensure proper calibration
   - Review bandwidth vs sensitivity trade-off

3. **CRC Errors**
   - Check frequency accuracy (crystal tolerance)
   - Verify sync word configuration
   - Review bitrate and bandwidth settings
   - Check for RF interference

4. **Transmission Issues**
   - Verify power amplifier configuration
   - Check antenna VSWR
   - Ensure adequate supply current capability
   - Review regulatory power limits

### Debug Configuration

```rust
// Enable debug logging
env_logger::init();
log::set_max_level(log::LevelFilter::Debug);

// Check interrupt status
let status = driver.get_irq_status()?;
println!("IRQ Status: {:?}", status);

// Verify configuration
println!("Current frequency: {:?}", driver.current_freq);
println!("Modulation params: {:?}", driver.current_mod_params);
```

## Advanced Features

### Frequency Hopping

```rust
let frequencies = [868_100_000, 868_300_000, 868_500_000];

for &freq in frequencies.iter().cycle() {
    driver.set_rf_frequency(freq)?;
    driver.calibrate_radio(CalibParams::PLL)?; // Recalibrate PLL

    // Transmit or receive on this frequency
    driver.set_rx(5000)?; // 5 second timeout

    if let Some(payload) = driver.process_irqs()? {
        println!("Received on {} MHz: {:?}", freq / 1_000_000, payload);
        break;
    }
}
```

### Power Optimization

```rust
// Low power RX with periodic wake-up
loop {
    // Wake up and listen
    driver.set_rx(1000)?; // Listen for 1 second

    if let Some(payload) = driver.process_irqs()? {
        println!("Message received: {:?}", payload);
    }

    // Enter sleep mode
    driver.set_sleep()?;
    std::thread::sleep(Duration::from_secs(10)); // Sleep 10 seconds
}
```

## References

- [SX126x Datasheet](https://www.semtech.com/products/wireless-rf/lora-connect/sx1262)
- [wM-Bus Standard EN 13757-4](https://www.cenelec.eu/)
- [ETSI EN 300 220 (EU Radio Regulations)](https://www.etsi.org/)
- [FCC Part 15 (US Radio Regulations)](https://www.fcc.gov/)

## License

This driver is part of the mbus-rs project. See the main project LICENSE file for details.
